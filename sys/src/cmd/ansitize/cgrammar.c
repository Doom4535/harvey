"# fake operators used to resolve if/else ambiguity \n"
"%left	DOSHIFT\n"
"%left	\"else\"\n"
"\n"
"# real operators - usual c precedence\n"
"%left	\":\"\n"
"%left	\",\"\n"
"%right	\"=\" \"+=\" \"-=\" \"*=\" \"/=\" \"%=\" \"<<=\" \">>=\" \"&=\" \"^=\" \"|=\"\n"
"%right	\"?\" \":\"\n"
"%left	\"||\"\n"
"%left	\"&&\"\n"
"%left	\"|\"\n"
"%left	\"^\"\n"
"%left	\"&\"\n"
"%left	\"==\"\n"
"%left	\"!=\"\n"
"%left	\"<\" \">\" \"<=\" \">=\"\n"
"%left	\"<<\" \">>\"\n"
"%left	\"+\" \"-\"\n"
"%left	\"*\" \"/\" \"%\"\n"
"%right	CAST\n"
"%left	sizeof UNARY \"!\" \"~\"\n"
"%right	\"--\" \"++\" \"->\" \".\" \"[\" \"]\" \"(\" \")\"\n"
"%left	STRING LSTRING\n"
"\n"
"# top-level loop\n"
"prog:\n"
"prog:	prog prog1\n"
"\n"
"prog1:	lstmt\n"
"prog1:	xdecl\n"
"prog1:	include\n"
"prog1:	pragma\n"
"prog1:	vararg\n"
"\n"
"cexpr:	expr,\n"
"\n"
"expr:	name\n"
"expr:	number\n"
"expr:	string+\n"
"expr:	Lstring+\n"
"expr:	char\n"
"expr:	Lchar\n"
"expr:	expr \"*\" expr\n"
"expr:	expr \"/\" expr\n"
"expr:	expr \"%\" expr\n"
"expr:	expr \"+\" expr\n"
"expr:	expr \"-\" expr\n"
"expr:	expr \">>\" expr\n"
"expr:	expr \"<<\" expr\n"
"expr:	expr \"<\" expr\n"
"expr:	expr \">\" expr\n"
"expr:	expr \"<=\" expr\n"
"expr:	expr \">=\" expr\n"
"expr:	expr \"==\" expr\n"
"expr:	expr \"!=\" expr\n"
"expr:	expr \"&\" expr\n"
"expr:	expr \"^\" expr\n"
"expr:	expr \"|\" expr\n"
"expr:	expr \"&&\" expr\n"
"expr:	expr \"||\" expr\n"
"expr:	expr \"?\" cexpr \":\" expr\n"
"expr:	expr \"=\" expr\n"
"expr:	expr \"+=\" expr\n"
"expr:	expr \"-=\" expr\n"
"expr:	expr \"*=\" expr\n"
"expr:	expr \"/=\" expr\n"
"expr:	expr \"%=\" expr\n"
"expr:	expr \"<<=\" expr\n"
"expr:	expr \">>=\" expr\n"
"expr:	expr \"&=\" expr\n"
"expr:	expr \"^=\" expr\n"
"expr:	expr \"|=\" expr\n"
"expr:	\"*\" expr	%prec UNARY\n"
"expr:	\"&\" expr	%prec UNARY\n"
"expr:	\"+\" expr	%prec UNARY\n"
"expr:	\"-\" expr	%prec UNARY\n"
"expr:	\"!\" expr\n"
"expr:	\"~\" expr\n"
"expr:	\"++\" expr\n"
"expr:	\"--\" expr\n"
"expr:	sizeof expr\n"
"expr:	sizeof \"(\" abtype \")\"\n"
"expr:	\"(\" abtype \")\" expr	%prec CAST\n"
"expr:	\"(\" abtype \")\" \"{\" init, \"}\"	%prec CAST\n"
"expr:	\"(\" cexpr \")\"\n"
"expr:	expr \"(\" expr,? \")\"\n"
"expr:	expr \"[\" cexpr \"]\"\n"
"expr:	expr \"++\"\n"
"expr:	expr \"--\"\n"
"expr:	\"va_arg\" \"(\" expr \",\" abtype \")\"\n"
"\n"
"sizeof:	\"sizeof\"\n"
"sizeof:	\"signof\"\n"
"sizeof:	\"alignof\"\n"
"\n"
"block1:	decl\n"
"block1:	lstmt\n"
"\n"
"block1*:	\n"
"block1*:	block1* block1\n"
"\n"
"block:	\"{\" block1* \"}\"\n"
"\n"
"label:	\"case\" expr \":\"\n"
"label:	\"case\" expr \"...\" expr \":\"\n"
"label:	\"default\" \":\"\n"
"label:	tag \":\"\n"
"\n"
"lstmt:	label* stmt\n"
"\n"
"stmt:	\";\"\n"
"stmt:	block\n"
"stmt:	cexpr \";\"\n"
"stmt:	\"if\" \"(\" cexpr \")\" lstmt	%prec DOSHIFT\n"
"stmt:	\"if\" \"(\" cexpr \")\" lstmt \"else\" lstmt	%prec \"else\"\n"
"stmt:	\"for\" \"(\" cexpr? \";\" cexpr? \";\" cexpr? \")\" lstmt\n"
"stmt:	\"while\" \"(\" cexpr \")\" lstmt\n"
"stmt:	\"do\" lstmt \"while\" \"(\" cexpr \")\" \";\"\n"
"stmt:	\"return\" cexpr? \";\"\n"
"stmt:	\"switch\" \"(\" cexpr \")\" lstmt\n"
"stmt:	\"ARGBEGIN\" stmt \"ARGEND\"\n"
"stmt:	\"break\" \";\"\n"
"stmt:	\"continue\" \";\"\n"
"stmt:	\"goto\" tag \";\"\n"
"\n"
"# can't happen in real code, but helps ignore some macros\n"
"# stmt:	expr block\n"
"\n"
"# Abstract declarator - abdec1 includes the slot where the name would go\n"
"abdecor:\n"
"abdecor:	\"*\" qname* abdecor\n"
"abdecor:	abdec1\n"
"\n"
"abdec1:	abdec1 \"(\" fnarg,? \")\"\n"
"abdec1:	abdecor \"[\" expr? \"]\"\n"
"abdec1:	\"(\" abdecor \")\"\n"
"\n"
"# Concrete declarator\n"
"decor:	tag\n"
"decor:	\"*\" qname* decor\n"
"decor:	\"(\" decor \")\"\n"
"decor:	decor \"(\" fnarg,? \")\"\n"
"decor:	decor \"[\" expr? \"]\"\n"
"\n"
"# Function argument\n"
"fnarg:	name\n"
"fnarg:	type abdecor\n"
"fnarg:	type decor\n"
"fnarg:	\"...\"\n"
"\n"
"# Initialized declarator\n"
"idecor:	decor\n"
"idecor:	decor \"=\" init\n"
"\n"
"# Class words\n"
"cname:	\"auto\"\n"
"cname:	\"static\"\n"
"cname:	\"extern\"\n"
"cname:	\"typedef\"\n"
"cname:	\"typestr\"\n"
"cname:	\"register\"\n"
"cname:	\"inline\"\n"
"\n"
"# Qualifier words\n"
"qname:	\"const\"\n"
"qname:	\"volatile\"\n"
"\n"
"# Type words\n"
"tname:	\"char\"\n"
"tname:	\"short\"\n"
"tname:	\"int\"\n"
"tname:	\"long\"\n"
"tname:	\"signed\"\n"
"tname:	\"unsigned\"\n"
"tname:	\"float\"\n"
"tname:	\"double\"\n"
"tname:	\"void\"\n"
"\n"
"cqname:	cname\n"
"cqname:	qname\n"
"\n"
"cqtname:	cqname\n"
"cqtname:	tname\n"
"\n"
"# Type specifier but not a tname\n"
"typespec:	typename\n"
"\n"
"# Types annotated with class info\n"
"#	typeclass:\n"
"#		cqname* typespec cqname*\n"
"#	|	cqname* tname cqtname*\n"
"#	|	cqname+\n"
"# except LR(1) can't seem to handle that (?)\n"
"\n"
"typeclass:	cqname* typespec cqname*\n"
"typeclass:	cqname* tname cqtname*\n"
"typeclass:	cqname+\n"
"\n"
"# Types without class info (check for class in higher level)\n"
"type:	typeclass\n"
"\n"
"abtype:	type abdecor\n"
"\n"
"# Declaration (finally)\n"
"decl:	typeclass idecor,? \";\"\n"
"\n"
"# External (top-level) declaration\n"
"xdecl:	decl\n"
"xdecl:	fndef\n"
"\n"
"fndef:	typeclass decor decl* block\n"
"\n"
"name:		id\n"
"typename:	id\n"
"tag:	id\n"
"\n"
"# struct/union\n"
"structunion:	\"struct\"\n"
"structunion:	\"union\"\n"
"\n"
"sudecor:	decor\n"
"sudecor:	tag? \":\" expr\n"
"\n"
"sudecl:	type sudecor,? \";\"\n"
"\n"
"typespec:	structunion tag\n"
"typespec:	structunion tag? \"{\" sudecl+ \"}\"\n"
"\n"
"initprefix:	\".\" tag\n"
"\n"
"expr:	expr \"->\" tag\n"
"expr:	expr \".\" tag\n"
"\n"
"# enum\n"
"typespec:	\"enum\" tag\n"
"typespec:	\"enum\" tag? \"{\" edecl, comma? \"}\"\n"
"edecl:	tag eqexpr?\n"
"eqexpr:	\"=\" expr\n"
"\n"
"# initializers\n"
"init:	expr\n"
"init:	\"{\" binit,? comma? \"}\"\n"
"\n"
"binit:	init\n"
"binit:	initprefix+ eq? init\n"
"\n"
"initprefix:	\"[\" expr \"]\"\n"
"\n"
"eq?:\n"
"eq?: \"=\"\n"
"\n"
"comma?:\n"
"comma?: \",\"\n"
"\n"
"initprefix+: initprefix\n"
"initprefix+: initprefix+ initprefix\n"
"\n"
"init,:	init\n"
"init,:	init, \",\" init\n"
"\n"
"binit,:	binit\n"
"binit,:	binit, \",\" binit\n"
"binit,?:\n"
"binit,?:	binit,\n"
"\n"
"\n"
"# the many number formats\n"
"numd:	/0|[1-9][0-9]*([Uu]?[Ll]?[Ll]?|[Ll][Ll]?[Uu]?)/\n"
"numo:	/0[0-7]*([Uu]?[Ll]?[Ll]?|[Ll][Ll]?[Uu]?)/\n"
"numx:	/0[Xx][0-9A-Fa-f]+([Uu]?[Ll]?[Ll]?|[Ll][Ll]?[Uu]?)/\n"
"numf:	/([0-9]+\\.[0-9]*|[0-9]*\\.[0-9]+)([eE][+\\-]?[0-9]+)?[FfLl]?/\n"
"numfx:	/0[Xx]([0-9A-Fa-f]+\\.[0-9A-Fa-f]*|[0-9A-Fa-f]*\\.[0-9A-Fa-f]+)([pP][+\\-]?[0-9]+)?[FfLl]?/\n"
"\n"
"# catch-all for malformed numbers\n"
"numbad:	/[0-9][0-9A-Za-z_]+/\n"
"\n"
"number:	numd\n"
"number:	numo\n"
"number:	numx\n"
"number:	numf\n"
"number:	numfx\n"
"number:	numbad\n"
"\n"
"# constants strings and characters\n"
"string:	/\"([^\"\\\\]|\\\\.)*\"/\n"
"Lstring:	/L\"([^\"\\\\]|\\\\.)*\"/\n"
"char:	/'([^'\\\\]|\\\\.)*'/\n"
"Lchar:	/L'([^'\\\\]|\\\\.)*'/\n"
"\n"
"# must be after all literal strings!\n"
"id:	/[_A-Za-z¡-￿][A-Za-z0-9_¡-￿]*/\n"
"\n"
"# special notations - should be created implicitly\n"
"tag?:\n"
"tag?:	tag\n"
"\n"
"cexpr?:\n"
"cexpr?:	cexpr\n"
"\n"
"expr?:\n"
"expr?:	expr\n"
"\n"
"expr,:	expr\n"
"expr,:	expr, \",\" expr\n"
"\n"
"expr,?:\n"
"expr,?:	expr,\n"
"\n"
"block?:\n"
"block?:	block\n"
"\n"
"stmt*:\n"
"stmt*:	stmt* stmt\n"
"\n"
"lstmt*:\n"
"lstmt*:	lstmt* lstmt\n"
"\n"
"decl*:\n"
"decl*:	decl* decl\n"
"\n"
"label*:\n"
"label*:	label* label\n"
"\n"
"fnarg,:	fnarg\n"
"fnarg,:	fnarg, \",\" fnarg\n"
"\n"
"fnarg,?:\n"
"fnarg,?:	fnarg,\n"
"\n"
"idecor,:	idecor\n"
"idecor,:	idecor, \",\" idecor\n"
"\n"
"idecor,?:\n"
"idecor,?:	idecor,\n"
"\n"
"qname+:	qname\n"
"qname+:	qname+ qname\n"
"\n"
"qname*:\n"
"qname*:	qname+\n"
"\n"
"cqname+:	cqname\n"
"cqname+:	cqname+ cqname\n"
"\n"
"cqname*:\n"
"cqname*:	cqname+\n"
"\n"
"cqtname+:	cqtname\n"
"cqtname+:	cqtname+ cqtname\n"
"\n"
"cqtname*:\n"
"cqtname*:	cqtname+\n"
"\n"
"sudecor,:	sudecor\n"
"sudecor,:	sudecor, \",\" sudecor\n"
"\n"
"sudecor,?:\n"
"sudecor,?:	sudecor,\n"
"\n"
"sudecl+:	sudecl\n"
"sudecl+:	sudecl+ sudecl\n"
"\n"
"eqexpr?:\n"
"eqexpr?:	eqexpr\n"
"\n"
"edecl,: edecl\n"
"edecl,: edecl, \",\" edecl\n"
"\n"
"include:	/#include[ \\t].*/\n"
"vararg:	/(#pragma[ \\t]+vararg.*\\n+)*(#pragma[ \\t]+vararg.*\\n)/\n"
"pragma:	/#pragma.*/\n"
"%ignore	/[ \\t\\n]+/\n"
"%ignore	/#(.|\\\\\\n)*/\n"
"%ignore	$//.*$\n"
"%ignore	$/\\*(.|\\n)*\\*/$s\n"
"# %ignore	$/\\*([^\\*]|\\*+([^/]|\\n)|\\n)*\\*/$\n"
"\n"
"string+: string\n"
"string+: string+ string\n"
"\n"
"Lstring+: Lstring\n"
"Lstring+: Lstring+ Lstring\n"
"\n"
"xxx:\n"
