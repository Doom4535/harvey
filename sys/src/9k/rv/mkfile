# rv mkfile - risc-v polarfire icicle rv64 kernel

# before changing RVARCH, be sure to "mk nuke"
<rvarch.$RVARCH

CONF=${ARCH}cpu
CONFLIST=${ARCH}cpu ${ARCH}cpuf ${ARCH}fs
EXTRACOPIES=fsstand

objtype=riscv64
</$objtype/mkfile
p=9

CFLAGS=$CFLAGS $CONFDEF
AFLAGS=$AFLAGS $CONFDEF

9k:V:	$p$CONF

# <| ../mk/mkparts $CONF; awk -f ../mk/parse $CONF
<|awk -f ../mk/parse $CONF
<../mk/bootmkfile
<../mk/portmkfile

# OBJ=$MACH $CONF.root.$O $CONF.$O $DEVS $PORT
OBJ=$MACH $PORT $DEVS $CONF.$O $CONF.root.$O

$p$CONF:	$CONF.c $OBJ $LIB
	$CC $CFLAGS '-DKERNDATE='`{date -n} $CONF.c
	# at 2gb physical.
	$LD -o $target $LDFLAGS -T$KTZERO -R4096 $OBJ &
	# .bin for temu, for tecpu
	$LD -a >$target.bin.list $LDFLAGS -o $target.bin -H1 -T$KTZERO -R8 $OBJ &
	wait
	size $target
	gzip <$target.bin >$target.gz
	aux/mkubootimage -l `{echo $KTZERO | sed 's/0xf+[8ce]?/0x/'} \
		$target.gz $target.uim && rm -f $target.gz # for u-boot
	# aux/mkubootimage -l `{echo $KTZERO | sed 's/0xf+[8ce]?/0x/'} \
	#	$target.bin $target.uim

#	# -H5 -P0x020000 sets INITTEXTP
#	$LD -o $target.elf -S -H5 -k -T$KTZERO -P$KTZERO -E_main -R8 $OBJ &
#	dd -ibs 32 -skip 1 -obs 8192 <$target >$target.bin

$p$CONF.bin $p$CONF.uim: $p$CONF
	;

# don't strip the gzipped kernels -- too frustrating when that's all you have!
$p%.gz:D:	$p%
	gzip -9 <$p$stem >$p$stem.gz
$p%.lz:D:	$p%
	lzip -9 <$p$stem >$p$stem.lz

# we don't need gzipped kernels otherwise, so don't make them
install:V:	$p$CONF $p$CONF.bin $p$CONF.uim
	cp -x $prereq /$objtype/ &
	if (! ~ $#EXTRACOPIES 0)
		echo -n 'installing on: '
	for(i in $EXTRACOPIES)
		{ 9fs $i && cp -x $prereq /n/$i/$objtype && echo -n $i... & }
	wait
	echo

start.$O strap.$O mtrap.$O:	${objtype}l.h start.h
l64.$O fp.$O fakemtrap.$O sbiecall.$O: ${objtype}l.h

$CONF.$O:	$objtype.h
arch%.$O:	$objtype.h
begin.$O:	$objtype.h
devarch.$O:	$objtype.h ../port/error.h /$objtype/include/ureg.h
fpu.$O:		$objtype.h /$objtype/include/ureg.h
ioconf.$O:	$objtype.h
main.$O:	$objtype.h io.h init.h reboot.h
memory.$O:	$objtype.h
mmu.$O:		$objtype.h
trap.$O:	../port/error.h io.h $objtype.h
trap.$O:	/sys/include/tos.h /$objtype/include/ureg.h

devether.$O:	../port/error.h ../port/netif.h etherif.h
devrtc.$O:	../port/error.h
ether%.$O:	../port/error.h ../port/netif.h etherif.h io.h
ethergem.O:	$objtype.h
etherigbepci.$O: ../port/ethermii.h
kbd.$O:		../port/error.h io.h
pci.$O:		io.h
%sbi%.$O:	$objtype.h
sd%.$O:		$objtype.h
uarti8250.$O:	$objtype.h

${objtype}l.h:D:	$objtype.h ${objtype}ladd.h
	{rc ../mk/mkenum $objtype.h; cat $objtype^ladd.h} >$target

#reboot.h reboot.out:D:	reboottramp.$O restart.$O ${objtype}l.h mem.h
#	$LD -a >$target.list -s -T0xbff05000 -R8 -o reboot.out \
#		reboottramp.$O restart.$O

# -T argument must match sys->reboottramp in dat.h (see acid), as 32 bits.
# currently assumes 1GB at PHYSMEM and lives at the top.
# "mk -f ktzmkfile" if PHYSMEM or BANK0SIZE or MACHSTKSZ or Mach changes.
reboot.h reboot.out:D:	rebootcode.$O ${objtype}l.h mem.h
	$LD -a >$target.list -l -s -T0xbff05000 -R8 -o reboot.out rebootcode.$O
	size reboot.out
	{echo 'uchar rebootcode[]={'; exec2hex reboot.out; echo '};'} >reboot.h

$CONF.rr:	../mk/mkrr $CONF root/$CONF.proto root/$O.cpu
	../mk/mkrr $CONF root/$CONF.proto

$ARCH.clean:V:
	rm -f $ARCH^*.c [9bz]$ARCH^* [9bz]$ARCH^*.gz boot$ARCH^*.* $p$ARCH^*.list
	rm -f prktzero.[$OS] [$OS].prktzero

$ARCH.nuke:V:
	rm -f $objtype^l.h reboot.h
